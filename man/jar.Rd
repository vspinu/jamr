% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jar.R
\name{jar}
\alias{jar}
\alias{unjar}
\title{Serialize data.frames by rows.}
\usage{
jar(obj, file, append = FALSE)

unjar(file)
}
\arguments{
\item{obj}{Atomic vector or list, with or without attributes}

\item{file}{Archive file name.}

\item{append}{If \code{TRUE} the data is appended to existing file. It's up
to the user to ensure that new data is compatible with the data from the
archive file. See also \code{\link{jar_csv}}.}
}
\value{
\code{unjar} returns de-serialized \code{data.frame}; \code{jar}
    returns input object invisibly.
}
\description{
This format is intended to be accessed from standalone C++ for row by row
processing without loading the full data into memory. Only
\code{data.frames} are currently supported.
}
\details{
Because columns are not stored in contiguous blocks the speed of \code{jar}
serialization is considerably lower than that of \code{\link{jam}}, but
still comparable with the speed of \code{writeRDS(..., compress=F)}.

List columns are not currently supported.

The term \code{jar} has nothing to do with java archives, it's about
"JAmming by Rows" and about those cylindrical objects where you store your
jam in.
}
\examples{
\dontrun{
  jar(iris)
  all.equal(iris, unjar("./data/iris.rjar"))
}
}
\author{
Vitalie Spinu
}

