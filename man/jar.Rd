% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jar.R
\name{jar}
\alias{jar}
\alias{unjar}
\title{Serialize data.frames by rows.}
\usage{
jar(obj, file, append = FALSE, rows_per_chunk = -1)

unjar(file, chunks = 0, bind = FALSE)
}
\arguments{
\item{obj}{Atomic vector or list, with or without attributes}

\item{file}{Archive file name.}

\item{append}{If \code{TRUE} the data is appended to existing file resulting
in multi-chunk archive. No attributes are stored for appended chunks
which could result in wrong or even corrupted de-serialization of factor
levels. See also \code{\link{jar_csv}} for a common use case.}

\item{rows_per_chunk}{If too small, serialization or deserialization will be
slower but can result in smaller archive sizes because type-size
optimization is performed on smaller chunks. Default is to write
everything in one chunk.}
}
\value{
\code{unjar} returns de-serialized \code{data.frame}; \code{jar}
    returns input object invisibly.
}
\description{
This format is intended to be accessed from standalone C++ for row by row
processing without loading the full data into memory. Only
\code{data.frames} are currently supported.
}
\details{
Because columns are not stored in contiguous blocks the speed of \code{jar}
serialization is considerably lower than that of \code{\link{jam}}, but
still comparable with the speed of \code{writeRDS(..., compress=F)}.

List columns are not currently supported.

The term \code{jar} has nothing to do with java archives, it's about
"JAmming by Rows" and about those cylindrical objects where you store your
jam in.
}
\examples{
\dontrun{
  jar(iris)
  all.equal(iris, unjar("./data/iris.rjar"))
}
}
\author{
Vitalie Spinu
}

